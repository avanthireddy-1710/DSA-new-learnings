#include<iostream>
#include<vector>
using namespace std;

int binarySearch(vector<int> arr, int tar){
    int st = 0, end = arr.size() - 1;

    while (st <= end){
        int mid = st + (st - end)/2;
        if (tar > arr[mid]){
            st = mid + 1;
        } else if (tar < arr[mid]){
            end = mid - 1;
        } else{
            return mid;
        }
    }
    return -1;
}
/*
In worst case scenarios, mid = (st + end)/2 can give wrong answers on coding platforms. So we use st + (st-end)/2 as an alternative.
Both are mathematically equal but in the 2nd case, we are subtracting 2 values so that there won't be any overflow.
*/

int main(){
//Linear search has O(n) T.C while Binary search has O(log n) T.C. Binary search will be applie donly on sorted arrays which may be ascending or descending.
vector<int> arr1={-1,3,5,7,8,11};
cout<<binarySearch(arr1,7)<<endl;
vector<int> arr2={0,4,25,34,68};
cout<<binarySearch(arr2,25)<<endl;
vector<int> arr3={-1,0,1};
cout<<binarySearch(arr3,22)<<endl;
return 0;
}
/*
analyzing the T.C,
search space => n->n/2->n/4->n/8->.....->1
can be written as n/2^0->n/2^1->n/2^2->.....->n/2^k
n/2^k=1  ->  n=2^k  ->  k=log n (base2)
So, T.C = O(log n)
